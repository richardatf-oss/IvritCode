<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IvritCode v1.0 — Aleph-Olam Engine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="IvritCode is a deterministic symbolic engine where Hebrew letters (א–ת) act as operators over 23 registers (א–ת + Aleph-Olam A), evolving in base 22."
  />
  <style>
    :root {
      --bg: #050711;
      --bg-alt: #0c101f;
      --fg: #f7f7ff;
      --accent: #ffd54a;
      --accent-soft: rgba(255, 213, 74, 0.12);
      --border: #252a3d;
      --muted: #9ca3c7;
      --mono: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular,
        Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      --radius-lg: 14px;
      --radius-sm: 8px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      font-family: var(--sans);
      background: radial-gradient(circle at top, #18213d 0, #050711 45%, #020308 100%);
      color: var(--fg);
      min-height: 100vh;
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }
    a:hover { text-decoration: underline; }

    .page {
      max-width: 1280px;
      margin: 0 auto;
      padding: 24px 16px 40px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 16px 20px;
      border-radius: var(--radius-lg);
      background: linear-gradient(135deg, #101427, #050711);
      border: 1px solid var(--border);
      box-shadow: 0 18px 40px rgba(0,0,0,0.6);
    }

    header h1 {
      margin: 0;
      font-size: 1.7rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      display: flex;
      align-items: baseline;
      gap: 10px;
    }

    header h1 span.he {
      font-size: 1.4rem;
      color: var(--accent);
      font-weight: 700;
    }

    header p {
      margin: 0;
      color: var(--muted);
      max-width: 70ch;
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1.6fr) minmax(0, 1.2fr);
      gap: 18px;
    }
    @media (max-width: 1040px) {
      .layout { grid-template-columns: minmax(0, 1fr); }
    }

    .card {
      border-radius: var(--radius-lg);
      background: var(--bg-alt);
      border: 1px solid var(--border);
      padding: 14px 16px 16px;
      box-shadow: 0 12px 28px rgba(0,0,0,0.45);
    }

    .card h2 {
      margin: 0 0 8px;
      font-size: 1rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--accent);
    }

    .card h3 {
      margin: 8px 0 6px;
      font-size: 0.95rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .card p {
      margin: 4px 0;
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .card ul {
      margin: 4px 0 4px 18px;
      padding: 0;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .card li { margin: 2px 0; }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 213, 74, 0.4);
      background: var(--accent-soft);
      color: var(--accent);
      font-size: 0.7rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .row {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 6px;
    }

    .row label {
      font-size: 0.85rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .row label span.right {
      font-size: 0.75rem;
      opacity: 0.8;
    }

    textarea,
    input[type="number"] {
      width: 100%;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: #050714;
      color: var(--fg);
      padding: 8px 10px;
      font-family: var(--mono);
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }

    textarea:focus,
    input[type="number"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(255,213,74,0.4);
      background: #07091a;
    }

    textarea {
      min-height: 96px;
      resize: vertical;
    }

    input[type="number"] {
      text-align: center;
      -moz-appearance: textfield;
    }

    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .register-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .cell {
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: #06081a;
      padding: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .cell.global {
      grid-column: span 4;
      border-color: var(--accent);
      background: radial-gradient(circle at top, #2b2540 0, #06081a 50%);
    }

    .cell label {
      font-size: 0.8rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 4px;
    }

    .cell label span.index {
      font-size: 0.7rem;
      opacity: 0.7;
    }

    .controls {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: 1px solid var(--accent);
      background: radial-gradient(circle at top, #ffe18a 0, #f6c640 40%, #f9b93a 100%);
      color: #222;
      font-weight: 600;
      padding: 7px 16px;
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    button.secondary {
      background: transparent;
      color: var(--muted);
      border-color: var(--border);
      box-shadow: none;
    }

    button:hover {
      filter: brightness(1.04);
      box-shadow: 0 8px 22px rgba(0,0,0,0.7);
    }

    button.secondary:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    pre {
      margin: 6px 0 0;
      padding: 8px 10px;
      border-radius: var(--radius-sm);
      background: #050714;
      border: 1px solid var(--border);
      font-family: var(--mono);
      font-size: 0.8rem;
      line-height: 1.5;
      max-height: 360px;
      overflow: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .opcode-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 6px;
      max-height: 260px;
      overflow-y: auto;
    }

    .opcode-item {
      display: flex;
      align-items: baseline;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .opcode-item .letter {
      font-size: 1rem;
      color: var(--accent);
      min-width: 1.6rem;
      text-align: center;
    }

    .opcode-item .name {
      font-weight: 600;
      color: #eaeafc;
      min-width: 4.5rem;
    }

    .opcode-item .summary {
      flex: 1;
      opacity: 0.9;
    }

    .note {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 4px;
    }

    footer {
      font-size: 0.78rem;
      color: var(--muted);
      text-align: center;
      margin-top: 12px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>
        <span class="he">אִבְרִיתְקוֹד</span>
        IvritCode v1.0 — Aleph-Olam Engine
      </h1>
      <p>
        IvritCode is a deterministic symbolic engine in which the 22 Hebrew letters
        (א–ת) act as <strong>operators</strong> over a 23-register state vector
        (א–ת plus Aleph-Olam <code>A</code>), evolving entirely in base&nbsp;22.
        Letters are instructions, registers are storage; niqqud and cantillation
        are reserved for future modifiers and structural syntax.
      </p>
    </header>

    <div class="layout">
      <!-- LEFT: explanation -->
      <section class="card">
        <span class="pill">How this engine works</span>
        <h2>State · Letters · Base&nbsp;22</h2>
        <p>
          The machine state <code>R</code> is a vector of 23 registers:
          <strong>22 letter-registers א…ת</strong> and the global register
          <strong>A (Aleph-Olam)</strong>. Each register stores a single digit
          in base&nbsp;22: a number in <code>0..21</code>.
        </p>

        <h3>Execution</h3>
        <ul>
          <li>Set the registers below to choose the <strong>initial state</strong> <code>R(0)</code>.</li>
          <li>Type a program of Hebrew letters (א–ת) in the text area.</li>
          <li>
            On <strong>Run Program</strong>, the engine:
            <ul>
              <li>extracts only IvritCode letters (א–ת),</li>
              <li>applies each letter as an operator on the full state, in order,</li>
              <li>records every step in the execution trace,</li>
              <li>produces a final state <code>R(n)</code>.</li>
            </ul>
          </li>
        </ul>

        <h3>Arithmetic (Base&nbsp;22)</h3>
        <p>
          All arithmetic happens in <code>ℤ<sub>22</sub></code>. After every
          operation, values are reduced modulo 22, so every register always
          stays in <code>0..21</code>.
        </p>
        <p class="note">
          Example: if a letter computes <code>r[i] + 1</code> and the current
          value is <code>21</code>, the new value becomes <code>0</code>.
        </p>

        <h3>Letters as Operators</h3>
        <p>
          Each Hebrew letter is an <strong>opcode</strong>. For example:
        </p>
        <ul>
          <li><strong>ב Bet</strong> — adds the first half of the alphabet into the second half, pairwise.</li>
          <li><strong>ל Lamed</strong> — sums all letter-registers into <code>A</code> and recenters them around the mean.</li>
          <li><strong>ש Shin</strong> — performs a nonlinear mix in blocks of four letters.</li>
        </ul>
        <p class="note">
          The right-hand panel lists all opcodes with short descriptions.
        </p>
      </section>

      <!-- CENTER: console -->
      <section class="card">
        <span class="pill">Engine console</span>
        <h2>Registers &amp; Program</h2>

        <div class="row">
          <label>
            Initial Registers (א–ת &amp; A)
            <span class="right">values in base&nbsp;22 (0–21)</span>
          </label>
          <div id="registerGrid" class="register-grid">
            <!-- filled by script -->
          </div>
        </div>

        <div class="row">
          <label for="programInput">
            Program text
            <span class="right">only letters א–ת are executed; other characters are ignored.</span>
          </label>
          <textarea
            id="programInput"
            placeholder="Example: בראשית or בבלש..."
            dir="rtl"
          ></textarea>
        </div>

        <div class="controls">
          <button id="runBtn" type="button">▶ Run Program</button>
          <button id="resetBtn" type="button" class="secondary">⟳ Reset</button>
        </div>

        <div class="row">
          <label>
            Execution trace &amp; final state
            <span class="right">for debugging and learning the opcodes.</span>
          </label>
          <pre id="output">(trace and final state will appear here)</pre>
        </div>
      </section>

      <!-- RIGHT: opcodes & commentary -->
      <section class="card">
        <span class="pill">Opcodes &amp; meanings</span>
        <h2>Letters as Instructions</h2>
        <p>
          This list summarizes what each letter does in the v1.0 core semantics.
          All operations are 23-wide: they touch the whole alphabet, not just a
          small “working quartet”.
        </p>
        <div id="opcodeRef" class="opcode-list"></div>

        <h3>Kabbalistic Commentary</h3>
        <p>
          The engine also computes a <strong>non-executing commentary</strong>:
          program gematria, global movement of the letters, and the motion of
          Aleph-Olam <code>A</code>. This is symbolic interpretation only; it
          does not influence execution.
        </p>
        <pre id="kabbalahOutput">(gematria and symbolic breakdown will appear here)</pre>

        <p class="note">
          Niqqud (vowel points) and cantillation marks are currently ignored by
          the core engine, but are reserved for future versions as instruction
          modifiers and structural syntax. The present implementation treats
          only the base letters (א–ת) as opcodes.
        </p>
      </section>
    </div>

    <footer>
      IvritCode v1.0 · 23 registers · base-22 arithmetic · letters as operators.
      Commentary is interpretive only and does not alter program behavior.
    </footer>
  </div>

  <!-- Core VM (global IvritVM) -->
  <script src="./src/vm.js"></script>

  <!-- UI wiring -->
  <script>
    (function () {
      const VM = window.IvritVM;
      if (!VM) {
        console.error("IvritVM not found. Make sure src/vm.js is loaded.");
        return;
      }

      const LETTERS = VM.LETTERS;
      const INDEX_A = VM.INDEX_A;

      const GEMATRIA = {
        "א": 1, "ב": 2, "ג": 3, "ד": 4, "ה": 5,
        "ו": 6, "ז": 7, "ח": 8, "ט": 9, "י": 10,
        "כ": 20, "ך": 20, "ל": 30, "מ": 40, "ם": 40,
        "נ": 50, "ן": 50, "ס": 60, "ע": 70, "פ": 80,
        "ף": 80, "צ": 90, "ץ": 90, "ק": 100, "ר": 200,
        "ש": 300, "ת": 400
      };

      const OPCODE_INFO = {
        "א": { name: "Alef",  summary: "Identity / frame (no-op)" },
        "ב": { name: "Bet",   summary: "Pairwise addition (first → second half)" },
        "ג": { name: "Gimel", summary: "Pairwise multiplication (first → second half)" },
        "ד": { name: "Dalet", summary: "Difference pairs across halves" },
        "ה": { name: "Hei",   summary: "Sign map across letters, A = net sign" },
        "ו": { name: "Vav",   summary: "Swap halves (א–כ) with (ל–ת)" },
        "ז": { name: "Zayin", summary: "Increment all letters" },
        "ח": { name: "Chet",  summary: "Decrement all letters" },
        "ט": { name: "Tet",   summary: "Square all letters, A = sum of squares" },
        "י": { name: "Yod",   summary: "Broadcast A into all letters" },
        "כ": { name: "Kaf",   summary: "Sliding window sum (size 4)" },
        "ל": { name: "Lamed", summary: "Global sum into A, recenter letters" },
        "מ": { name: "Mem",   summary: "Moving average (3-point), A = mean" },
        "נ": { name: "Nun",   summary: "Global negation (letters and A)" },
        "ס": { name: "Samekh",summary: "Rotation by A" },
        "ע": { name: "Ayin",  summary: "Max correlation of halves → A" },
        "פ": { name: "Pe",    summary: "Expose Alef into A and neighbors" },
        "צ": { name: "Tsadi", summary: "Compare halves; expose extremes" },
        "ק": { name: "Qof",   summary: "Mirror & tilt alphabet" },
        "ר": { name: "Resh",  summary: "Reseed from A with stride" },
        "ש": { name: "Shin",  summary: "Nonlinear mix in quartets, A = max |r[i]|" },
        "ת": { name: "Tav",   summary: "Quartet rotation in blocks of four" }
      };

      const grid = document.getElementById("registerGrid");
      const programInput = document.getElementById("programInput");
      const output = document.getElementById("output");
      const kabbalahOutput = document.getElementById("kabbalahOutput");
      const opcodeRef = document.getElementById("opcodeRef");
      const runBtn = document.getElementById("runBtn");
      const resetBtn = document.getElementById("resetBtn");

      function buildRegisterGrid() {
        if (!grid) return;
        grid.innerHTML = "";
        LETTERS.forEach((letter, i) => {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.innerHTML = `
            <label>${letter}<span class="index">#${i}</span></label>
            <input type="number" value="0" data-index="${i}" />
          `;
          grid.appendChild(cell);
        });
        const aCell = document.createElement("div");
        aCell.className = "cell global";
        aCell.innerHTML = `
          <label>A<span class="index">#${INDEX_A} (Aleph-Olam)</span></label>
          <input type="number" value="0" data-index="${INDEX_A}" />
        `;
        grid.appendChild(aCell);
      }

      function renderOpcodeReference() {
        if (!opcodeRef) return;
        opcodeRef.innerHTML = "";
        LETTERS.forEach(letter => {
          const info = OPCODE_INFO[letter];
          if (!info) return;
          const div = document.createElement("div");
          div.className = "opcode-item";
          div.innerHTML = `
            <span class="letter">${letter}</span>
            <span class="name">${info.name}</span>
            <span class="summary">— ${info.summary}</span>
          `;
          opcodeRef.appendChild(div);
        });
      }

      function collectState() {
        const state = VM.createState();
        if (!grid) return state;
        grid.querySelectorAll("input").forEach(input => {
          const idx = Number(input.dataset.index);
          const raw = Number(input.value);
          const val = Number.isFinite(raw) ? raw : 0;
          state[idx] = val;
        });
        return state;
      }

      function setState(state) {
        if (!grid) return;
        grid.querySelectorAll("input").forEach(input => {
          const idx = Number(input.dataset.index);
          input.value = String(state[idx] ?? 0);
        });
      }

      function resetUI() {
        if (grid) {
          grid.querySelectorAll("input").forEach(input => (input.value = "0"));
        }
        if (programInput) programInput.value = "";
        if (output) output.textContent = "(trace and final state will appear here)";
        if (kabbalahOutput) {
          kabbalahOutput.textContent =
            "(gematria and symbolic breakdown will appear here)";
        }
      }

      function explainStep(step) {
        const letter = step.letter;
        const info = OPCODE_INFO[letter] || {};
        let text = "";
        text += `Step ${step.index} — Letter ${letter} (${info.name || "?"}): ${info.summary || ""}\n`;

        const changes = [];
        for (let i = 0; i < step.after.length; i++) {
          if (step.before[i] !== step.after[i]) {
            const regName = i === INDEX_A ? "A" : LETTERS[i];
            changes.push({ regName, index: i, before: step.before[i], after: step.after[i] });
          }
        }
        if (changes.length === 0) {
          text += "  No registers changed.\n\n";
          return text;
        }
        text += "  Changes:\n";
        changes.forEach(c => {
          text += `    ${c.regName} (index ${c.index}): ${c.before} → ${c.after}\n`;
        });
        text += "\n";
        return text;
      }

      function computeProgramGematria(instructions) {
        let total = 0;
        const perLetter = [];
        instructions.forEach(ch => {
          const value = GEMATRIA[ch] ?? 0;
          total += value;
          perLetter.push({ letter: ch, value });
        });
        return { total, perLetter };
      }

      function sumLetters(state) {
        let sum = 0;
        for (let i = 0; i < LETTERS.length; i++) sum += state[i] ?? 0;
        return sum;
      }

      function interpretNumber(n) {
        if (n === 1) return "1 — אחד (echad): unity, Keter, indivisible source.";
        if (n === 2) return "2 — duality: giver/receiver, above/below.";
        if (n === 3) return "3 — triad: thesis–antithesis–synthesis.";
        if (n === 4) return "4 — structure, directions, dalet/door.";
        if (n === 5) return "5 — ה: revelation, window, breath.";
        if (n === 6) return "6 — ו: connection, hook between realms.";
        if (n === 7) return "7 — struggle and Shabbat; sword and rest.";
        if (n === 8) return "8 — beyond nature, the doorway past 7.";
        if (n === 10) return "10 — י: point of creation, seed.";
        if (n === 13) return "13 — אחד / אהבה (echad/ahavah): oneness through love.";
        if (n === 18) return "18 — חי (chai): life-force.";
        if (n === 22) return "22 — the full Aleph-Bet, all channels open.";
        if (n <= 0) return n + " — movement into contraction / concealment.";
        if (n > 400) return n + " — composite light (sum of many letters).";
        return n + " — composite value; factor into letter-gates.";
      }

      function generateKabbalisticCommentary(initialState, finalState, instructions) {
        if (!instructions || instructions.length === 0) {
          return "No IvritCode letters (א–ת) were executed, so no Kabbalistic pattern was written into the state.";
        }

        let text = "";
        const { total, perLetter } = computeProgramGematria(instructions);
        text += "Program Gematria:\n";
        text += "  Letters: " + instructions.join("") + "\n";
        text += "  Breakdown:\n";
        perLetter.forEach(item => {
          text += `    ${item.letter}: ${item.value}\n`;
        });
        text += `  Total gematria of program: ${total}\n`;
        text += "  Interpretation: " + interpretNumber(total) + "\n\n";

        const sumInit = sumLetters(initialState);
        const sumFinal = sumLetters(finalState);
        const deltaLetters = sumFinal - sumInit;

        text += "Letter-Registers (א–ת) — Global Movement:\n";
        text += `  Initial sum of letters: ${sumInit}\n`;
        text += `  Final sum of letters:   ${sumFinal}\n`;
        text += `  Change (Δ):             ${deltaLetters}\n`;
        if (deltaLetters !== 0) {
          text += "  Reading: total 'weight of letters' ";
          text += deltaLetters > 0
            ? "increased — intensification of expressed light.\n"
            : "decreased — contraction / focusing of the light.\n";
          text += "  |Δ| Interpretation: " + interpretNumber(Math.abs(deltaLetters)) + "\n\n";
        } else {
          text += "  Reading: total weight unchanged — transformation by rearrangement.\n\n";
        }

        const aInit = initialState[INDEX_A];
        const aFinal = finalState[INDEX_A];
        const deltaA = aFinal - aInit;

        text += "Aleph-Olam (A) — Global Register:\n";
        text += `  Initial A: ${aInit}\n`;
        text += `  Final A:   ${aFinal}\n`;
        text += `  Change (ΔA): ${deltaA}\n`;
        if (deltaA !== 0) {
          text += deltaA > 0
            ? "  Reading: A accumulated additional content from the letters.\n"
            : "  Reading: A released or exposed content back into the letters.\n";
          text += "  |ΔA| Interpretation: " + interpretNumber(Math.abs(deltaA)) + "\n\n";
        } else {
          text += "  Reading: A stayed numerically the same — consulted, but not displaced.\n\n";
        }

        text += "Sample of State (א..ד and A):\n";
        ["א","ב","ג","ד"].forEach((name, idx) => {
          const before = initialState[idx];
          const after = finalState[idx];
          const diff = after - before;
          text += `  ${name}: ${before} → ${after} (Δ=${diff})\n`;
        });
        text += `  A: ${aInit} → ${aFinal} (Δ=${deltaA})\n\n`;

        text += "Narrative Sketch:\n";
        text += "  • The program’s gematria sets an overall 'tone'.\n";
        text += "  • The letter-sum shows how much of that tone entered the vessels.\n";
        text += "  • The motion of A shows how the hidden global register gathered or released that tone.\n";

        return text;
      }

      function handleRun() {
        const initialState = collectState();
        const program = programInput ? programInput.value || "" : "";
        const result = VM.runProgram(initialState, program, 1000);
        const finalState = result.finalState;
        const trace = result.trace;
        const instructions = result.instructions;

        setState(finalState);

        if (!output) return;

        if (trace.length === 0) {
          output.textContent =
            "No executable letters (א–ת) were found in the program.\n\n" +
            "Initial and final state are identical:\n\n" +
            JSON.stringify(initialState, null, 2);
          if (kabbalahOutput) {
            kabbalahOutput.textContent =
              "No IvritCode letters (א–ת) were executed, so no Kabbalistic pattern was written into the state.";
          }
          return;
        }

        let text = "";
        text += "Program (interpreted letters only):\n";
        text += instructions.join("") + "\n\n";
        text += "Initial State R(23):\n";
        text += JSON.stringify(initialState, null, 2) + "\n\n";
        text += "Execution Trace:\n\n";
        trace.forEach(step => { text += explainStep(step); });
        text += "Final State R(23):\n";
        text += JSON.stringify(finalState, null, 2);
        output.textContent = text;

        if (kabbalahOutput) {
          kabbalahOutput.textContent = generateKabbalisticCommentary(
            initialState,
            finalState,
            instructions
          );
        }
      }

      buildRegisterGrid();
      renderOpcodeReference();
      resetUI();

      if (runBtn) runBtn.addEventListener("click", handleRun);
      if (resetBtn) resetBtn.addEventListener("click", resetUI);
    })();
  </script>
</body>
</html>
