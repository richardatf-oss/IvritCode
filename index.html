<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IvritCode v1.0 — Register Console & Engine</title>

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f1115;
      color: #eaeaf0;
      margin: 0;
      padding: 1.5rem;
    }

    h1 {
      margin-top: 0;
      font-weight: 600;
      letter-spacing: 0.04em;
    }

    h2 {
      margin-top: 2rem;
      font-weight: 500;
    }

    .subtitle {
      color: #9aa0b4;
      margin-bottom: 1.5rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .cell {
      background: #181b22;
      border: 1px solid #2a2f3a;
      border-radius: 6px;
      padding: 0.5rem;
      text-align: center;
    }

    .cell label {
      display: block;
      font-size: 1.1rem;
      margin-bottom: 0.25rem;
    }

    .cell input {
      width: 100%;
      background: #0f1115;
      color: #ffffff;
      border: 1px solid #3a3f4b;
      border-radius: 4px;
      padding: 0.25rem;
      font-size: 0.95rem;
      text-align: center;
    }

    .cell.global {
      border-color: #c9a227;
      background: #1b1a10;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1.1fr);
      gap: 1.5rem;
    }

    textarea {
      width: 100%;
      min-height: 120px;
      background: #0f1115;
      color: #ffffff;
      border: 1px solid #2a2f3a;
      border-radius: 6px;
      padding: 0.75rem;
      font-family: "Noto Sans Hebrew", system-ui, sans-serif;
      font-size: 1rem;
      resize: vertical;
    }

    .actions {
      display: flex;
      gap: 1rem;
      align-items: center;
      margin: 1rem 0 1.5rem;
    }

    button {
      background: #2c6bed;
      color: #ffffff;
      border: none;
      border-radius: 6px;
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      cursor: pointer;
    }

    button.secondary {
      background: #3a3f4b;
    }

    button:hover {
      filter: brightness(1.1);
    }

    pre {
      background: #0b0d12;
      border: 1px solid #2a2f3a;
      border-radius: 6px;
      padding: 1rem;
      overflow-x: auto;
      font-size: 0.9rem;
      color: #d0d6ff;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .note {
      font-size: 0.85rem;
      color: #a0a6b8;
      margin-top: 0.25rem;
    }

    .two-column-right {
      display: grid;
      grid-template-rows: auto auto;
      gap: 1rem;
    }

    .opcode-reference {
      background: #0b0d12;
      border: 1px solid #2a2f3a;
      border-radius: 6px;
      padding: 0.75rem;
      max-height: 260px;
      overflow-y: auto;
      font-size: 0.85rem;
    }

    .opcode-item {
      margin-bottom: 0.35rem;
    }

    .opcode-item span.letter {
      font-weight: 600;
      margin-right: 0.25rem;
    }

    .opcode-item span.name {
      color: #f0d16a;
      margin-right: 0.25rem;
    }

    .opcode-item span.summary {
      color: #c0c6da;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <h1>IvritCode — Register Console & Base Engine</h1>
  <div class="subtitle">
    Seed the 22 letter-registers (א–ת) and Aleph-Olam (A), enter a program, and see exactly what each IvritCode letter does to the state.
  </div>

  <div class="layout">
    <!-- Left: Registers & Program -->
    <div>
      <h2>Registers (State Vector R²³)</h2>
      <div id="registerGrid" class="grid"></div>

      <h2>Program</h2>
      <textarea id="programInput"
        placeholder="Enter IvritCode program here using letters א–ת.&#10;For now, niqqud and trop are ignored by the engine and will be added later."></textarea>
      <div class="note">
        Only the base letters א–ת are interpreted as instructions; all other characters are currently ignored.
      </div>

      <div class="actions">
        <button id="runBtn">Run Program</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
    </div>

    <!-- Right: Output + Opcode Reference -->
    <div class="two-column-right">
      <div>
        <h2>Execution Trace</h2>
        <pre id="output">(trace and final state will appear here)</pre>
      </div>

      <div>
        <h2>Opcode Reference (Base Letters)</h2>
        <div id="opcodeRef" class="opcode-reference"></div>
      </div>
    </div>
  </div>

  <script>
    // --- Core constants ------------------------------------------------------

    // Hebrew alphabet (22 letters)
    const LETTERS = "אבגדהוזחטיכלמנסעפצקרשת".split("");

    // Map from letter to index 0..21
    const LETTER_INDEX = new Map(LETTERS.map((ch, idx) => [ch, idx]));

    // Indices for Aleph-Olam (A)
    const INDEX_A = 22;

    // Role binding (default): α→א(0), β→ב(1), γ→ג(2), δ→ד(3)
    const ROLE_ALPHA = 0;
    const ROLE_BETA  = 1;
    const ROLE_GAMMA = 2;
    const ROLE_DELTA = 3;

    // Human-readable info for each opcode
    const OPCODE_INFO = {
      "א": {
        name: "Alef",
        summary: "Identity (no-op)",
        detail: "Does nothing to the registers; often used as a frame marker."
      },
      "ב": {
        name: "Bet",
        summary: "Addition",
        detail: "Adds register א (alpha) and ב (beta), stores result in ג (gamma)."
      },
      "ג": {
        name: "Gimel",
        summary: "Multiplication",
        detail: "Multiplies registers א (alpha) and ב (beta), stores result in ד (delta)."
      },
      "ד": {
        name: "Dalet",
        summary: "Difference pair",
        detail: "Computes ג = ב − א and ד = א − ב."
      },
      "ה": {
        name: "Hei",
        summary: "Sign of α",
        detail: "Writes sign(א) into register ה: 1 if א>0, 0 if א=0, −1 if א<0."
      },
      "ו": {
        name: "Vav",
        summary: "Swap α and β",
        detail: "Swaps the values of א (alpha) and ב (beta)."
      },
      "ז": {
        name: "Zayin",
        summary: "Increment α",
        detail: "Increments register א (alpha) by 1."
      },
      "ח": {
        name: "Chet",
        summary: "Decrement α",
        detail: "Decrements register א (alpha) by 1."
      },
      "ט": {
        name: "Tet",
        summary: "Square α into γ",
        detail: "Squares register א (alpha) and stores the result into ג (gamma)."
      },
      "י": {
        name: "Yod",
        summary: "Load A into α",
        detail: "Loads Aleph-Olam (A) into register א (alpha)."
      },
      "כ": {
        name: "Kaf",
        summary: "Quartet sum → A",
        detail: "Sums א, ב, ג, ד and stores the total into A."
      },
      "ל": {
        name: "Lamed",
        summary: "Global sum → A",
        detail: "Sums all 22 letter registers (א–ת) and stores the total into A."
      },
      "מ": {
        name: "Mem",
        summary: "Quartet mean → γ",
        detail: "Computes the integer mean of א, ב, ג, ד and writes it into ג."
      },
      "נ": {
        name: "Nun",
        summary: "Negate α",
        detail: "Replaces register א (alpha) with its negation."
      },
      "ס": {
        name: "Samekh",
        summary: "Rotate letters",
        detail: "Cyclically rotates the 22 letter registers one step; A unchanged."
      },
      "ע": {
        name: "Ayin",
        summary: "Dot product → A",
        detail: "Dot product of א..כ with ל..ת; writes sum into A."
      },
      "פ": {
        name: "Pe",
        summary: "Expose α → A",
        detail: "Copies register א (alpha) into A."
      },
      "צ": {
        name: "Tsadi",
        summary: "Compare α and β → A",
        detail: "Compares א and ב: writes 1 to A if א>ב, 0 if equal, −1 if א<ב."
      },
      "ק": {
        name: "Qof",
        summary: "Mirror letters",
        detail: "Reverses the order of the 22 letter registers; A unchanged."
      },
      "ר": {
        name: "Resh",
        summary: "Reseed quartet from A",
        detail: "Sets א=A, ב=A+1, ג=A+2, ד=A+3."
      },
      "ש": {
        name: "Shin",
        summary: "Nonlinear mix",
        detail: "Applies: א'=א²+ב, ב'=ב²+ג, ג'=ג²+ד, ד'=ד²+א."
      },
      "ת": {
        name: "Tav",
        summary: "Rotate quartet",
        detail: "Rotates roles: א←ג, ב←ד, ג←א, ד←ב."
      }
    };

    // --- UI setup ------------------------------------------------------------

    const grid = document.getElementById("registerGrid");
    const output = document.getElementById("output");
    const programInput = document.getElementById("programInput");
    const opcodeRef = document.getElementById("opcodeRef");

    // Build letter register inputs
    LETTERS.forEach((letter, i) => {
      const cell = document.createElement("div");
      cell.className = "cell";

      cell.innerHTML = `
        <label>${letter}</label>
        <input type="number" value="0" data-index="${i}" />
      `;

      grid.appendChild(cell);
    });

    // Aleph-Olam (A)
    const aCell = document.createElement("div");
    aCell.className = "cell global";
    aCell.innerHTML = `
      <label>A</label>
      <input type="number" value="0" data-index="${INDEX_A}" />
    `;
    grid.appendChild(aCell);

    // Build opcode reference list
    function renderOpcodeReference() {
      const frag = document.createDocumentFragment();
      LETTERS.forEach(letter => {
        const info = OPCODE_INFO[letter];
        if (!info) return;
        const div = document.createElement("div");
        div.className = "opcode-item";
        div.innerHTML = `
          <span class="letter">${letter}</span>
          <span class="name">${info.name}</span>
          <span class="summary">— ${info.summary}</span>
        `;
        div.title = info.detail;
        frag.appendChild(div);
      });
      opcodeRef.innerHTML = "";
      opcodeRef.appendChild(frag);
    }
    renderOpcodeReference();

    function collectState() {
      const state = new Array(23).fill(0);
      grid.querySelectorAll("input").forEach(input => {
        const idx = Number(input.dataset.index);
        state[idx] = Number(input.value) || 0;
      });
      return state;
    }

    function setState(state) {
      grid.querySelectorAll("input").forEach(input => {
        const idx = Number(input.dataset.index);
        const value = state[idx] ?? 0;
        input.value = String(value);
      });
    }

    function resetUI() {
      grid.querySelectorAll("input").forEach(input => {
        input.value = "0";
      });
      programInput.value = "";
      output.textContent = "(trace and final state will appear here)";
    }

    // --- VM core: base letter semantics -------------------------------------

    function cloneState(state) {
      return state.slice();
    }

    function applyLetterOp(letter, state) {
      const idx = LETTER_INDEX.get(letter);
      if (idx == null) return; // ignore unknown

      const aIdx = ROLE_ALPHA;
      const bIdx = ROLE_BETA;
      const gIdx = ROLE_GAMMA;
      const dIdx = ROLE_DELTA;

      const a = state[aIdx];
      const b = state[bIdx];
      const g = state[gIdx];
      const d = state[dIdx];
      const AO = state[INDEX_A];

      switch (letter) {
        case "א": {
          // Identity: no-op
          break;
        }
        case "ב": {
          state[gIdx] = a + b;
          break;
        }
        case "ג": {
          state[dIdx] = a * b;
          break;
        }
        case "ד": {
          state[gIdx] = b - a;
          state[dIdx] = a - b;
          break;
        }
        case "ה": {
          const heiIndex = LETTER_INDEX.get("ה");
          let sign = 0;
          if (a > 0) sign = 1;
          else if (a < 0) sign = -1;
          state[heiIndex] = sign;
          break;
        }
        case "ו": {
          const tmp = state[aIdx];
          state[aIdx] = state[bIdx];
          state[bIdx] = tmp;
          break;
        }
        case "ז": {
          state[aIdx] = a + 1;
          break;
        }
        case "ח": {
          state[aIdx] = a - 1;
          break;
        }
        case "ט": {
          state[gIdx] = a * a;
          break;
        }
        case "י": {
          state[aIdx] = AO;
          break;
        }
        case "כ": {
          state[INDEX_A] = a + b + g + d;
          break;
        }
        case "ל": {
          let sum = 0;
          for (let i = 0; i < 22; i++) sum += state[i];
          state[INDEX_A] = sum;
          break;
        }
        case "מ": {
          const mean = Math.floor((a + b + g + d) / 4);
          state[gIdx] = mean;
          break;
        }
        case "נ": {
          state[aIdx] = -a;
          break;
        }
        case "ס": {
          const prev = state.slice(0, 22);
          for (let i = 0; i < 22; i++) {
            const from = (i - 1 + 22) % 22;
            state[i] = prev[from];
          }
          break;
        }
        case "ע": {
          let sum = 0;
          for (let i = 0; i <= 10; i++) {
            const u = state[i];
            const v = state[i + 11];
            sum += u * v;
          }
          state[INDEX_A] = sum;
          break;
        }
        case "פ": {
          state[INDEX_A] = a;
          break;
        }
        case "צ": {
          let sign = 0;
          if (a > b) sign = 1;
          else if (a < b) sign = -1;
          state[INDEX_A] = sign;
          break;
        }
        case "ק": {
          const prev = state.slice(0, 22);
          for (let i = 0; i < 22; i++) {
            state[i] = prev[21 - i];
          }
          break;
        }
        case "ר": {
          state[aIdx] = AO;
          state[bIdx] = AO + 1;
          state[gIdx] = AO + 2;
          state[dIdx] = AO + 3;
          break;
        }
        case "ש": {
          const newA = a * a + b;
          const newB = b * b + g;
          const newG = g * g + d;
          const newD = d * d + a;
          state[aIdx] = newA;
          state[bIdx] = newB;
          state[gIdx] = newG;
          state[dIdx] = newD;
          break;
        }
        case "ת": {
          const newA = g;
          const newB = d;
          const newG = a;
          const newD = b;
          state[aIdx] = newA;
          state[bIdx] = newB;
          state[gIdx] = newG;
          state[dIdx] = newD;
          break;
        }
        default: {
          break;
        }
      }
    }

    function runProgram(initialState, program, maxSteps = 1000) {
      const state = cloneState(initialState);
      const instructions = [];

      for (const ch of program) {
        if (LETTER_INDEX.has(ch)) {
          instructions.push(ch);
        }
      }

      const trace = [];
      const steps = Math.min(instructions.length, maxSteps);

      for (let i = 0; i < steps; i++) {
        const letter = instructions[i];
        const before = cloneState(state);
        applyLetterOp(letter, state);
        const after = cloneState(state);

        trace.push({
          index: i,
          letter,
          before,
          after
        });
      }

      return { finalState: state, trace, instructions };
    }

    // --- Helper: explain state changes --------------------------------------

    function explainStep(step) {
      const { letter, before, after, index } = step;
      const info = OPCODE_INFO[letter] || {};
      const name = info.name || "?";
      const summary = info.summary || "";
      const detail = info.detail || "";

      let text = "";
      text += `Step ${index} — Letter ${letter} (${name}): ${summary}\n`;
      if (detail) {
        text += `  ${detail}\n`;
      }

      // Find which registers changed
      const changes = [];
      for (let i = 0; i < after.length; i++) {
        if (before[i] !== after[i]) {
          // Index 0..21 are letters, 22 is A
          const regName = i === INDEX_A ? "A" : LETTERS[i];
          changes.push({
            index: i,
            regName,
            before: before[i],
            after: after[i]
          });
        }
      }

      if (changes.length === 0) {
        text += "  No registers changed.\n\n";
        return text;
      }

      text += "  Changes:\n";
      for (const c of changes) {
        text += `    ${c.regName} (index ${c.index}): ${c.before} → ${c.after}\n`;
      }
      text += "\n";

      return text;
    }

    // --- Hook up UI actions --------------------------------------------------

    document.getElementById("runBtn").addEventListener("click", () => {
      const initialState = collectState();
      const program = programInput.value || "";

      const { finalState, trace, instructions } = runProgram(initialState, program, 1000);

      // Update UI with final state
      setState(finalState);

      if (trace.length === 0) {
        output.textContent =
          "No executable letters (א–ת) found in program.\n\n" +
          "Initial and final state are identical:\n\n" +
          JSON.stringify(initialState, null, 2);
        return;
      }

      let text = "";
      text += "Program (interpreted letters only):\n";
      text += instructions.join("") + "\n\n";

      text += "Initial State R(23):\n";
      text += JSON.stringify(initialState, null, 2) + "\n\n";

      text += "Execution Trace (base letters only; niqqud/trop ignored for now):\n\n";
      for (const step of trace) {
        text += explainStep(step);
      }

      text += "Final State R(23):\n";
      text += JSON.stringify(finalState, null, 2);

      output.textContent = text;
    });

    document.getElementById("resetBtn").addEventListener("click", resetUI);
  </script>
</body>
</html>
