<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IvritCode v0.0 — Minimal Playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f9fafb;
      --accent: #fbbf24;
      --border: #1f2937;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1rem 1.5rem 0.5rem;
      border-bottom: 1px solid var(--border);
      background: radial-gradient(circle at 0% 0%, #1d2538, #050816 55%);
    }

    header h1 {
      margin: 0;
      font-size: 1.4rem;
      letter-spacing: 0.05em;
    }

    header h1 span {
      color: var(--accent);
    }

    header p {
      margin: 0.35rem 0 0.75rem;
      font-size: 0.9rem;
    }

    main {
      flex: 1;
      padding: 1rem 1.5rem 1.5rem;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      grid-template-rows: auto auto;
      gap: 1rem;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
      }
    }

    .card {
      background: #020617;
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      padding: 0.9rem;
      box-shadow: 0 12px 30px rgba(0,0,0,0.6);
    }

    .card h2 {
      margin: 0 0 0.5rem;
      font-size: 1rem;
    }

    textarea {
      width: 100%;
      min-height: 7rem;
      resize: vertical;
      padding: 0.7rem 0.8rem;
      border-radius: 0.7rem;
      border: 1px solid var(--border);
      background: #020617;
      color: #f9fafb;
      font-family: "Courier New", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 1.05rem;
      line-height: 1.4;
      direction: rtl;
    }

    textarea::placeholder {
      color: #6b7280;
    }

    .controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.45rem 1.1rem;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      background: linear-gradient(135deg, var(--accent), #f97316);
      color: #111827;
      box-shadow: 0 10px 30px rgba(251,191,36,0.4);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 5px 18px rgba(251,191,36,0.3);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    th, td {
      border-bottom: 1px solid #111827;
      padding: 0.3rem 0.25rem;
      text-align: right;
    }

    th {
      color: #9ca3af;
      font-weight: 500;
    }

    .reg-name {
      font-family: "SBL Hebrew", "Times New Roman", serif;
      font-size: 1.05rem;
    }

    .reg-name.global {
      color: var(--accent);
      font-weight: 700;
    }

    .value-cell {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      direction: ltr; /* ensure Arabic numerals render naturally */
    }

    .status {
      margin-top: 0.4rem;
      font-size: 0.8rem;
      color: #9ca3af;
      display: flex;
      justify-content: space-between;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    #traceList {
      list-style: none;
      padding-left: 0;
      margin: 0.3rem 0 0;
      max-height: 11rem;
      overflow: auto;
      font-size: 0.8rem;
    }

    #traceList li {
      border-bottom: 1px dashed #111827;
      padding: 0.15rem 0;
    }

    #traceList li:last-child {
      border-bottom: none;
    }

    #traceList code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      direction: ltr;
    }

    footer {
      padding: 0.5rem 1.5rem 1rem;
      font-size: 0.75rem;
      color: #6b7280;
      border-top: 1px solid #020617;
      background: #020617;
    }
  </style>
</head>
<body>
  <header>
    <h1>IvritCode <span>v0.0</span> — Aleph-Olam VM</h1>
    <p>Hebrew letters (א–ת) as opcodes, one global register <code>A</code>, and a working quartet (א,ב,ג,ד).</p>
  </header>

  <main>
    <!-- Program input -->
    <section class="card" style="grid-column: 1 / 2; grid-row: 1 / 2;">
      <h2>Program</h2>
      <textarea id="program" placeholder="Example: אבבגת
• א — no-op
• ב — add Alef+Bet → Gimel
• ג — multiply Alef⋅Bet → Dalet
• ת — rotate quartet (א,ב,ג,ד)"></textarea>
      <div class="controls">
        <button id="runBtn">▶ Run IvritCode</button>
        <span>Only letters א–ת execute. Niqqud and punctuation are ignored.</span>
      </div>
    </section>

    <!-- Registers -->
    <section class="card" style="grid-column: 2 / 3; grid-row: 1 / 2;">
      <h2>Registers</h2>
      <div style="max-height: 15rem; overflow:auto;">
        <table>
          <thead>
            <tr>
              <th>Register</th>
              <th>Index</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody id="registersBody"></tbody>
        </table>
      </div>
      <div class="status">
        <span>Steps: <strong id="stepsCount">0</strong></span>
        <span>Last program: <code id="lastProgram" dir="rtl"></code></span>
      </div>
    </section>

    <!-- Trace -->
    <section class="card" style="grid-column: 1 / 3; grid-row: 2 / 3;">
      <h2>Execution trace</h2>
      <div>Format: <code>[step] op → א,ב,ג,ד,A</code></div>
      <ol id="traceList"></ol>
    </section>
  </main>

  <footer>
    IvritCode v0.0 — base letter semantics only (Niqqud reserved for modifiers). Deterministic, 23-register state.
  </footer>

  <!-- Inline JS so we know exactly what's running -->
  <script>
    // ==== CORE VM (from SPEC.md) =========================================
    const HEBREW_LETTERS = "אבגדהוזחטיכלמנסעפצקרשת";
    const NUM_HEBREW_REGS = 22;
    const AO_INDEX = 22; // Aleph-Olam

    const ALEF = 0;
    const BET  = 1;
    const GIMEL = 2;
    const DALET = 3;

    const REGISTER_NAMES = [...HEBREW_LETTERS.split(""), "A"];

    function createState() {
      return { regs: new Array(NUM_HEBREW_REGS + 1).fill(0) };
    }

    function cloneState(state) {
      return { regs: state.regs.slice() };
    }

    function sign(x) {
      if (x > 0) return 1;
      if (x < 0) return -1;
      return 0;
    }

    function step(state, op) {
      const r = state.regs;
      const next = r.slice();

      const a = r[ALEF];
      const b = r[BET];
      const g = r[GIMEL];
      const d = r[DALET];
      const AO = r[AO_INDEX];

      switch (op) {
        case "א":
          // Identity (no-op)
          return state;

        case "ב":
          // g' = a + b
          next[GIMEL] = a + b;
          break;

        case "ג":
          // d' = a ⋅ b
          next[DALET] = a * b;
          break;

        case "ד":
          // g' = b − a ; d' = a − b
          next[GIMEL] = b - a;
          next[DALET] = a - b;
          break;

        case "ה": {
          // sign of Alef into ה
          const HEI = HEBREW_LETTERS.indexOf("ה");
          if (HEI !== -1) next[HEI] = sign(a);
          break;
        }

        case "ו":
          // swap a,b
          next[ALEF] = b;
          next[BET]  = a;
          break;

        case "ז":
          // increment Alef
          next[ALEF] = a + 1;
          break;

        case "ח":
          // decrement Alef
          next[ALEF] = a - 1;
          break;

        case "ט":
          // square into g
          next[GIMEL] = a * a;
          break;

        case "י":
          // load AO into a
          next[ALEF] = AO;
          break;

        case "כ":
          // quartet sum into AO
          next[AO_INDEX] = a + b + g + d;
          break;

        case "ל": {
          // sum all Hebrew regs into AO
          let sum = 0;
          for (let i = 0; i < NUM_HEBREW_REGS; i++) sum += r[i];
          next[AO_INDEX] = sum;
          break;
        }

        case "מ":
          // mean of quartet into g
          next[GIMEL] = Math.floor((a + b + g + d) / 4);
          break;

        case "נ":
          // negate a
          next[ALEF] = -a;
          break;

        case "ס":
          // cyclic rotation of 22 Hebrew regs
          for (let i = 0; i < NUM_HEBREW_REGS; i++) {
            const from = (i - 1 + NUM_HEBREW_REGS) % NUM_HEBREW_REGS;
            next[i] = r[from];
          }
          next[AO_INDEX] = AO;
          break;

        case "ע": {
          // dot product (א..כ) · (ל..ת)
          let sum = 0;
          for (let i = 0; i <= 10; i++) {
            const u = r[i];
            const v = r[i + 11];
            sum += u * v;
          }
          next[AO_INDEX] = sum;
          break;
        }

        case "פ":
          // expose Alef into AO
          next[AO_INDEX] = a;
          break;

        case "צ":
          // comparison: AO' = sign(a - b)
          next[AO_INDEX] = sign(a - b);
          break;

        case "ק":
          // mirror 0..21, AO unchanged
          for (let i = 0; i < NUM_HEBREW_REGS; i++) {
            next[i] = r[NUM_HEBREW_REGS - 1 - i];
          }
          next[AO_INDEX] = AO;
          break;

        case "ר":
          // reseed quartet from AO
          next[ALEF] = AO;
          next[BET]  = AO + 1;
          next[GIMEL] = AO + 2;
          next[DALET] = AO + 3;
          break;

        case "ש":
          // nonlinear mix
          next[ALEF] = a * a + b;
          next[BET]  = b * b + g;
          next[GIMEL] = g * g + d;
          next[DALET] = d * d + a;
          break;

        case "ת":
          // rotate quartet (g,d,a,b)
          next[ALEF] = g;
          next[BET]  = d;
          next[GIMEL] = a;
          next[DALET] = b;
          break;

        default:
          // ignore anything that isn't a base letter
          return state;
      }

      return { regs: next };
    }

    function runProgram(program, opts) {
      opts = opts || {};
      const trace = [];
      let state = createState();
      const maxSteps = opts.maxSteps ?? 10000;

      let steps = 0;
      let executedOps = "";

      for (const ch of program) {
        if (HEBREW_LETTERS.includes(ch)) {
          if (opts.trace) {
            trace.push(cloneState(state)); // before op
          }
          state = step(state, ch);
          executedOps += ch;
          steps++;
          if (steps >= maxSteps) break;
        }
      }

      if (opts.trace) {
        trace.push(cloneState(state)); // after last
      }

      return { final: state, trace, steps, executedOps };
    }

    // ==== UI WIRING ======================================================
    function renderRegisters(state, tbody) {
      const regs = state.regs;
      const rows = [];

      for (let i = 0; i < regs.length; i++) {
        const name = REGISTER_NAMES[i] ?? ("r" + i);
        const isGlobal = i === AO_INDEX;
        rows.push(
          `<tr>
            <td class="reg-name ${isGlobal ? "global" : ""}">${name}</td>
            <td class="value-cell">${i}</td>
            <td class="value-cell">${regs[i]}</td>
          </tr>`
        );
      }

      tbody.innerHTML = rows.join("");
    }

    function renderTrace(result, traceListEl) {
      const { trace, executedOps } = result;

      if (!executedOps || !trace || trace.length === 0) {
        traceListEl.innerHTML = "<li>No executable letters א–ת were found.</li>";
        return;
      }

      const items = [];
      const maxShown = 64;
      const stepsToShow = Math.min(executedOps.length, maxShown);

      for (let i = 0; i < stepsToShow; i++) {
        const op = executedOps[i];
        const stateAfter = trace[i + 1] || trace[trace.length - 1];
        const r = stateAfter.regs;

        const a = r[ALEF];
        const b = r[BET];
        const g = r[GIMEL];
        const d = r[DALET];
        const A = r[AO_INDEX];

        items.push(
          `<li><code>[${i + 1}] ${op}</code> → א=${a}, ב=${b}, ג=${g}, ד=${d}, A=${A}</li>`
        );
      }

      if (executedOps.length > maxShown) {
        items.push(
          `<li>… (${executedOps.length - maxShown} additional steps not shown)</li>`
        );
      }

      traceListEl.innerHTML = items.join("");
    }

    function setup() {
      const programEl = document.getElementById("program");
      const runBtn = document.getElementById("runBtn");
      const registersBody = document.getElementById("registersBody");
      const stepsCount = document.getElementById("stepsCount");
      const lastProgram = document.getElementById("lastProgram");
      const traceList = document.getElementById("traceList");

      if (!programEl || !runBtn || !registersBody || !stepsCount || !lastProgram || !traceList) {
        console.error("Missing UI elements");
        return;
      }

      if (!programEl.value.trim()) {
        programEl.value = "אבבגת";
      }

      const runOnce = () => {
        const src = programEl.value || "";
        const result = runProgram(src, { trace: true });
        renderRegisters(result.final, registersBody);
        renderTrace(result, traceList);
        stepsCount.textContent = String(result.steps);
        lastProgram.textContent = result.executedOps || "(no valid letters)";
      };

      runBtn.addEventListener("click", runOnce);
      programEl.addEventListener("keydown", (ev) => {
        if ((ev.ctrlKey || ev.metaKey) && ev.key === "Enter") {
          ev.preventDefault();
          runOnce();
        }
      });

      runOnce();
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", setup);
    } else {
      setup();
    }
  </script>
</body>
</html>
